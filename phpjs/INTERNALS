
the PHP/JavaScript interpreter
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
This document tries to describe as many of the internal data structures
and processing mechanisms as possible - before the author forgets most
of it again...



$js_vars[]
----------
Is an associative array of variables (names mapped to values). It is a
deeply nested array of arrays for variables that are itself arrays or
are in a namespace or part of an object instance itself.

Some examples in JS-notation and in the actual $js_vars[] notation:

   varname                  $js_vars["varname"]
   class.var1               $js_vars["class"]["var1"]
   class["var1"]            $js_vars["class"]["var1"]
   wiki.page.saveBack()     $js_vars["wiki"]["page"]["saveBack"]

The last is a function call, but functions are itself string variables,
with the value of an allowed callable function (see $js_funcs[] array)
associated to it.



----------------------------------------------------------------------------



the bytecode
¯¯¯¯¯¯¯¯¯¯¯¯
All the "JS_*" defines() on top of the compiler script part just give
(source-code-wise) meaningful names to the integer numbers associated
to each type of language tokesn. Some token names are only used in the
parser/tokenizer but most identify language constructs for the
interpreter.

The $bc array is first divided into all defined functions and the
main code block identified as "."

$bc = array(
   "." => array(             // the main() code block is called "."
      ...
   ),
   "def_js_func" => array(   // other functions are associated in the first
      ...                    // level sub array using their given name
   ),
);

Each block is a list of instructions or expressions the interpreter could
execute line-by-line. Every expression or instruction is itself an sub
array in that list. And code blocks can itself be part of some constructs
(in for-loops or as if-else-code). The first element in every bytecode
array entry always identifies (a JS_* constant) the token type.


Expressions
¯¯¯¯¯¯¯¯¯¯¯
Are the most basic construct in every programming language, and in phpjs
almost everything can be an expression. Expression usually give a value
back (regardless if that was used later). Also they are typically nested
with other expressions.

An expression is typically either a variable name, or a mathematical/bool
calcualtion or a plain value.


Code blocks
¯¯¯¯¯¯¯¯¯¯¯
Every array in the $bc structure is feed through the interpreters
js_block() function, which walks through the entries and dispatches
them to language construct and expression handlers (if there is an
expression directly in a code block, then it is called a "void expression"
because the result gets thrown away, typical for JS_ASSIGN).

Also each code block (an array) can nest other code blocks also arrays.
That is, if you have something like the following in your code:

{
   {
      {
         x = x + 1;
      }
   }
}

it got converted into:  array( array( array( array(JS_ASSIGN, ...) ) ) ),
while the interpreter indeed not really needs such constructs and the
parser may omit them anyway in some cases.


Assignments
¯¯¯¯¯¯¯¯¯¯¯
Always have two parameters, the first is always a variable name (so the
JS_VAR is redundant here for ordinary variable names without array suffix)
and the second is typically just a value or another var name or an
expression like JS_MATH.

...[0] = JS_ASSIGN
...[1] = array( JS_VAR, "variable_name")
...[2] = array( JS_VALUE, 17.222);


Math expressions
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
Are most often seen as the second parameter in a JS_ASSIGN statement, and
return the end result as expression value.

...[0] = JS_MATH
...[1] = array( JS_VAR, "anothervar" )
...[2] = "+"
...[3] = array( JS_VALUE, 53.772 )
...[4] = "-"
...[5] = array( JS_FCALL, ... )        // or any other expression again

Every value, sub-expression or variable name is separated by an operator
sign from each other - a JS_MATH typically has at least two sub-expressions,
but is the number is actually unlimited. The operations +- and */% are
separated from each other by the parser already, so that you would never see
them mixed in one JS_MATH expression array.

The JS_MATH also handles some boolean (&&, ||) expressions

...[0] = JS_MATH
...[1] = array( JS_VAR, "anothervar" )
...[2] = "||"
...[3] = array( JS_CMP, ... )

and bit-function operations like & and | or ^ and it even has support
for a few unary operations (just one operand), where the parser takes
care to only assign one single element to the JS_MATH array.


Boolean math
¯¯¯¯¯¯¯¯¯¯¯¯
Have basically two operands whose values get compared. The operands
can itself be expressions (but often are simply one variable and a
value).

...[0] = JS_CMP
...[1] = array( JS_VAR, "var1" )
...[2] = ">="
...[3] = array( JS_MATH, ... )


Function calls
¯¯¯¯¯¯¯¯¯¯¯¯¯¯
A function call always has the desired function name as first parameter,
and multiple others as parameters to the to be called function. The
function name is thereby evaluated as variable name and the contents
of that variable name instead match to an JS-function or a registered /
allowed PHP-interface-function.

...[0] = JS_FUNC
...[1] = "function_name"
...[2] = array( JS_VALUE, "param1" )
...[3] = array( JS_VAR, "funcparam2_from_variable" )

This expression of course returns the function return value as result ;)


Language funtions
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
Language-builtin functions like "print" and "echo" have a relaxed call
syntax in that they don't need paranthesis around parameters. Likewise
they have specialized implementation in phpjs to accomodate that they
can occour in an unlimited amount.

...[0] = JS_RT
...[1] = JS_PRINT              // limited no of language functions
...[2] = array( JS_VAR, "param1" )
...[3] = ...


Conditional Loops
¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯¯
There are four types of conditional loops in phpjs, but not all have
the same construct/representation. The three described herein share that
they only have one condition to evaluate. The condition always is at
bytecode position [2] and the to be executed code block at [3]:

...[0] = JS_COND
...[1] = JS_WHILE
...[2] = array( JS_CMP, ... )
...[3] = array( ... )             // a code block

An $bc[1]=JS_DO - loop simply has the condition checked after execution
of the code block. Whereas an IF is special in that it does not loop and
could have multiple conditions and code blocks (a tree of them). Only
one of the code blocks got executed though:

...[0] = JS_COND
...[1] = JS_IF
...[2] = array( JS_CMP, ... )     // expression
...[3] = array( ... )             // a code block
...[4] = array( JS_CMP, ... )
...[5] = array( ... )
...[6] = array( JS_VALUE, true )  // the JS_ELSE tree
...[7] = array( ... )


For-Loops
¯¯¯¯¯¯¯¯¯
The parser formats the for loop constructs specially so that the
interpreter doesn't have to deal with all too much of its semantics.
Especially the first (init) parameter from the for(x=0; ...) isn't
exactly keept - the parser separated it out before the for-loop
construct (where it actually belongs).
The to be executed code block is at $bc[3] while $bc[1] contains the
break condition and $bc[2] the expression to be executed after the
code block (should have better been merged into [3] by the parser,
but whatever...)

...[0] = JS_FOR
...[1] = array( JS_CMP, ... )        // condition
...[2] = array( JS_ASSIGN, ... )     // post-expression
...[3] = array( ... )                // code block


breaks
¯¯¯¯¯¯
All loop constructs take care of the JS_BREAK statement which has
an optional count parameter:

...[0] = JS_BREAK
...[1] = 1                     // is set to 1 normally


